---
title: 经典算法问题 - 最大连续子数列和
categories: 算法
tags: 
     - Testing
---

<font size=6>最大连续子数列和</font>一道很经典的算法问题，给定一个数列，其中可能有正数也可能有负数，我们的任务是找出其中连续的一个子数列（不允许空序列），使它们的和尽可能大。我们一起用多种方式，逐步优化解决这个问题。

为了更清晰的理解问题，首先我们先看一组数据：
8
-2 6 -1 5 4 -7 2 3
第一行的8是说序列的长度是8，然后第二行有8个数字，即待计算的序列。
对于这个序列，我们的答案应该是14，所选的数列是从第2个数到第5个数，这4个数的和是所有子数列中最大的。
<!--more-->
**最暴力的做法，复杂度O(N^3)**
暴力求解也是容易理解的做法，简单来说，我们只要用两层循环枚举起点和终点，这样就尝试了所有的子序列，然后计算每个子序列的和，然后找到其中最大的即可，C语言代码如下：

    #include <stdio.h>
    
    //N是数组长度，num是待计算的数组，放在全局区是因为可以开很大的数组
    int N, num[1024];
    
    int main()
    {
    //输入数据
    scanf("%d", &N);
    for(int i = 1; i <= N; i++)
    scanf("%d", &num[i]);
    
    int ans = num[1]; //ans保存最大子序列和，初始化为num[1]能保证最终结果正确
    //i和j分别是枚举的子序列的起点和终点，k所在循环计算每个子序列的和
    for(int i = 1; i <= N; i++) {
    for(int j = i; j <= N; j++) {
    int s = 0;
    for(int k = i; k <= j; k++) {
    s += num[k];
    }
    if(s > ans) ans = s;
    }
    }
    printf("%d\n", ans);
    
    return 0;
    }

这个算法的时间复杂度是O(N^3)，复杂度的计算方法可参考《算法导论》第一章，如果我们的计算机可以每秒计算一亿次的话，这个算法在一秒内只能计算出500左右长度序列的答案。

**动态规划的魅力，O(N)解决！**
很多动态规划算法非常像数学中的递推。我们如果能找到一个合适的递推公式，就能很容易的解决问题。
我们用dp[n]表示以第n个数结尾的最大连续子序列的和，于是存在以下递推公式：
dp[n] = max(0, dp[n-1]) + num[n]
仔细思考后不难发现这个递推公式是正确的，则整个问题的答案是max(dp[m]) | m∈[1, N]。C语言代码如下：

    #include <stdio.h>
    
    //N是数组长度，num是待计算的数组，放在全局区是因为可以开很大的数组
    int N, num[134217728];
    
    int main()
    {
    //输入数据
    scanf("%d", &N);
    for(int i = 1; i <= N; i++)
    scanf("%d", &num[i]);
    
    num[0] = 0;
    int ans = num[1];
    for(int i = 1; i <= N; i++) {
    if(num[i - 1] > 0) num[i] += num[i - 1];
    else num[i] += 0;
    if(num[i] > ans) ans = num[i];
    }
    
    printf("%d\n", ans);
    
    return 0;
    }



文章来自：[http://conw.net/archives/9/](http://conw.net/archives/9/)