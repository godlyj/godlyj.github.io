<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">




  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-loading-bar.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="data center failures,">










<meta name="description" content="混合式存储相关论文阅读总结 论文目录一、混合存储综述二、基于磁盘和固态硬盘的混合存储系统研究综述三、一种时间敏感的SSD和HDD高效混合存储模型四、A Hybrid Solid-State Storage Architecture for the Performance, Energy Consumption, and Lifetime Improvement五、Design Guidelines">
<meta name="keywords" content="data center failures">
<meta property="og:type" content="article">
<meta property="og:title" content="混合式存储相关论文阅读总结">
<meta property="og:url" content="http://yoursite.com/2021/07/28/混合式存储相关论文阅读总结/index.html">
<meta property="og:site_name" content="丷人冂口">
<meta property="og:description" content="混合式存储相关论文阅读总结 论文目录一、混合存储综述二、基于磁盘和固态硬盘的混合存储系统研究综述三、一种时间敏感的SSD和HDD高效混合存储模型四、A Hybrid Solid-State Storage Architecture for the Performance, Energy Consumption, and Lifetime Improvement五、Design Guidelines">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2021-07-28T06:39:10.606Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="混合式存储相关论文阅读总结">
<meta name="twitter:description" content="混合式存储相关论文阅读总结 论文目录一、混合存储综述二、基于磁盘和固态硬盘的混合存储系统研究综述三、一种时间敏感的SSD和HDD高效混合存储模型四、A Hybrid Solid-State Storage Architecture for the Performance, Energy Consumption, and Lifetime Improvement五、Design Guidelines">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2021/07/28/混合式存储相关论文阅读总结/">





  <title>混合式存储相关论文阅读总结 | 丷人冂口</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">丷人冂口</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">让懂的人懂，让不懂的人不懂。让世界是世界，我甘心是我的茧。</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="Searching..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/07/28/混合式存储相关论文阅读总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lyjgod">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="丷人冂口">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">混合式存储相关论文阅读总结</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-07-28T14:14:05+08:00">
                2021-07-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/论文分析/" itemprop="url" rel="index">
                    <span itemprop="name">论文分析</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="混合式存储相关论文阅读总结"><a href="#混合式存储相关论文阅读总结" class="headerlink" title="混合式存储相关论文阅读总结"></a>混合式存储相关论文阅读总结</h1><hr>
<h2 id="论文目录"><a href="#论文目录" class="headerlink" title="论文目录"></a>论文目录</h2><p>一、混合存储综述<br><br>二、基于磁盘和固态硬盘的混合存储系统研究综述<br><br>三、一种时间敏感的SSD和HDD高效混合存储模型<br><br>四、A Hybrid Solid-State Storage Architecture for the Performance, Energy Consumption, and Lifetime Improvement<br><br>五、Design Guidelines of Storage Class Memory/Flash Hybrid Solid-State Drive Considering System Architecture, Algorithm and Workload Characteristic<br><br>六、Design of Hybrid SSDs With Storage Class Memory and nand Flash Memory<br><br>七、一种面向SSD-HDD混合存储的热区跟踪替换算法<br><br>八、Cost, Capacity, and Performance Analyses for Hybrid SCM/NAND Flash SSD<br></p>
<hr>
<h2 id="一、混合存储综述"><a href="#一、混合存储综述" class="headerlink" title="一、混合存储综述"></a>一、混合存储综述</h2><p><strong>内容解读</strong>：<br>&emsp;&emsp;文章作为一篇综述，分别从混合存储概念、存储介质的特性、以及混合存储分类这 3 个方面对混合存储进行了介绍。<br>&emsp;&emsp;混合存储系统将大部分的用户数据都存放在低速设备上，由高速设备来接收或者响应数据请求。它的主要目标是使存储的数据充分利用不同存储介质的特性，在保证存储系统容量的同时尽可能地提高性价比。<br>&emsp;&emsp;文章对于存储介质主要提到了三种，NVRAM，SSD（NAND 闪存），HDD。<br>针对分类，文章中主要提到了一下几种：<br>（1）NVRAM和HDD的混合存储<br>&emsp;&emsp;在这种方式下，文章首先提出了，将NVRAM作为数据缓存的模式，并且提到了两种页面置换策略：CLOCK-Pro和ARC。同时NVRAM的非易失性质可以让脏数据不需要再额外写入非易失性存储设备中，以此来提高性能。其次，文章还提到了使用NVRAM记录日志，但仅仅也只是提供一个缓冲的作用，当数据积累到一定量或者周期结束以后，再将其写入到磁盘。<br>（2）不同转速磁盘的混合存储<br>&emsp;&emsp;把热数据放在转速快的磁盘，把冷数据放在转速慢的磁盘。但是提升十分有限。<br>（3）SSD和HDD的混合存储<br>&emsp;&emsp;这是目前比较主流也是效果比较好的架构，文章重点介绍了这种混合存储架构，分别从以下几个方面进行：系统架构、映射策略、热点数据识别、数据迁移策略、最优化存储介质用量组合。<br>首先是系统架构，文章提到了两种，分别是缓存架构和同层架构。关于映射策略，也就是逻辑地址应该被映射到何处，文章则提到了三种方式，按照block、按照文件、按照extent（规定固定大小的block块）。同样的，数据迁移策略也分为这三种粒度。而数据迁移策略需要考虑的内容不止粒度大小，还有迁移周期的考虑。最后对于最优化存储介质用量组合，有静态分配方式，也有根据任务变化的动态分配。<br><br><strong>读后思考及想法：</strong><br>&emsp;&emsp;文章作为一篇综述，仅仅只是介绍了混合存储的基本情况。阐述了目前混合存储的几个方向，以及存在的难点和问题。但是对于初学者来说，对于混合式存储的了解还是很有帮助的。不过因为文章比较老，所以也漏了RAM和SSD的混合存储这种架构。</p>
<hr>
<h2 id="二、基于磁盘和固态硬盘的混合存储系统研究综述"><a href="#二、基于磁盘和固态硬盘的混合存储系统研究综述" class="headerlink" title="二、基于磁盘和固态硬盘的混合存储系统研究综述"></a>二、基于磁盘和固态硬盘的混合存储系统研究综述</h2><p><strong>内容解读：</strong><br>&emsp;&emsp;提出目前流行的基于SSD和HDD 的混合存储系统主要分为将SSD作为HDD的缓存的架构和将HDD和SSD作为设备同层架构。针对这两种不同类型的架构对其中涉及的关键技术、应用场景、性能优化进行分析。<br>&emsp;&emsp;<strong>第一种架构</strong>  ，将SSD作为HDD的缓存结构，总体上讲就是将SSD作为HDD的cache，类似于内存中的cache，逻辑地址和HDD的物理地址是一一对应的，当I/O请求到来时，首先到SSD的cache中进行查找，找到则直接返回，没找到则从HDD中查找并放入SSD形成的cache中。并且给出了一个使用NAND闪存作为DRAM和磁盘之间的二级缓存的应用。虽然提高了性能，但是未考虑闪存的磨损情况以及系统的垃圾回收。在之后的研究中，不断对其加以改进，首先，针对闪存的物理特点，将闪存的缓冲部分分为写缓存和读缓存，这样，在读缓存中就可以不受写前擦除的影响，同时也能够减少功耗。其次，增加了对于数据的替换，提出了两种不同的替换规则，一种是以数据块粒度对数据热度进行判定，提出了一种称为温度感知(Temperature．Aware caching，TAC)的页面替换策略，TAC追踪并记录一个块中页的访问情况作为块冷热的判断依据。将热数据块存放在SSD缓存中，将冷数据块存放在磁盘中。另一种则是提出了三种存在于一级缓存的脏页处理方法，分别称为Clean-Write(CW)、Dual-Write(DW)和Iazy-Cleaning(LC)三种写操作模式。cw模式是当一个脏页从主存缓存替换出来时仅仅只写入磁盘；DW模式则是同时将数据写入磁盘和二级缓存，这与TAC模式是相同的；LC模式则是现将数据写入二级缓存，然后在合适的时候写回磁盘。<br>&emsp;&emsp;<strong>第二种架构</strong> ，更为普遍，是将SSD和HDD放在同层，也就是说数据只会存在SSD和HDD其中之一，根据页面的工作负载来决定将页面存放的磁盘类型，并根据迁移代价来决定是否将页面在SSD和 HDD上进行迁移。具有读密集型的页放置在SSD上，而具有 写密集型和频繁更新的页则放置在HDD上。因此，决定页面放置的算法至关重要。文中提到了一个很有意思的算法。每个页面被放置在闪存读队列、闪存写队列、磁盘读队列、磁盘写队 列中的一个，并根据闪存读队列、磁盘读队列、磁盘写队列、磁闪存写队列从高到低的优先级进行进行页面的置换。在之后的改进中，提出为页面引入一个处于hot和cold中间的warm状态，避免那些偶尔变热的cold页面进行迁移，减少了不必要的迁移操作。<br><br><br><strong>读后思考及想法：</strong><br><br>&emsp;&emsp;因为文章是一篇综述，其中包含了大量文献的研究成果，所以在文中只是简单提到一些思想和算法，并未详细道出其实现方法，但是还是有很多的值得阅读以及思考的地方。<br>&emsp;&emsp;首先，在把SSD作为HDD的缓存这个架构中，将SSD缓存分为写缓存和读缓存，虽然减少了SSD写前擦除的影响，但是另外比较重要的点，文章并未提出，那就是闪存的损耗，很明显，写缓存的损耗会远大于读缓存的损耗。那么在分配时，是否可以使用动态分配的方法，分为两个链表，分为写缓存页和读缓存页，然后设置自由缓存页区，当读写缓存需要的时候进行分配，并且可以设置一个简单的计数器，每次都分配那些使用次数少的页区，并且那些读写缓存中长时间未使用的页则直接放回自由区，以此来平衡读写缓存的损耗。当然还要考虑效率的影响，不过在损耗和效率之间应该可以找到一个平衡点。<br>&emsp;&emsp;其次，在SSD和HDD作为同层的架构中，还提到了一种多队列的优先级调度。有些类似于操作系统中的多级队列调度算法。那么冷热数据分离，是否也可以用这样的方法，设置多个队列，每个队列都代表一定的访问量级，并且有计数器，当一个队列中的数据被访问多次到达一定数量时就放到下一个队列中，一定时间不被访问就放回前一级队列，这样就可以根据队列来进行冷热数据的分离。<br>&emsp;&emsp;除了两种架构的描述之外，文章还提出了一种有意思的观点，虽然SSD已具有优良的随机读性能，然而目前大多数的中低端的固态硬盘的随机写性能却低于传统的磁盘，另外频 繁的写操作也会给固态硬盘带来磨损。因此甚至可以使用传统的磁盘作为SSD的写缓存。<br>&emsp;&emsp;联系到备份策略方面，也就是RAID方面，可以将两个磁盘组成一个RAIDl，并将这个RAIDl作为固态硬盘磁盘阵列RAID4的写缓存，其中一个HDD作为RAID4的校验盘，而另外一个HDD则作为RAID4的写缓存，负责写请求，并且还充当了另一个磁盘失效时作为恢复的磁盘。由于HDD作为检验盘因此避免了SSD的校验更新操作，就可以减少SSD的损耗，同时又能够保证备份数据的安全。</p>
<hr>
<h2 id="三、基于磁盘和固态硬盘的混合存储系统研究综述"><a href="#三、基于磁盘和固态硬盘的混合存储系统研究综述" class="headerlink" title="三、基于磁盘和固态硬盘的混合存储系统研究综述"></a>三、基于磁盘和固态硬盘的混合存储系统研究综述</h2><p><strong>内容解读：</strong><br><br>&emsp;&emsp;文章提出的模型是一种SSD和HDD同级的架构模式。为了充分发挥SSD的性能，也就需要将读倾向负载的hot页面分配到SSD存储，写倾向负载的页面或者cold页面分配到HDD存储，从而利用SSD和HDD不对称的Ｉ／Ｏ特性来降低系统总的Ｉ／Ｏ延迟。<br><br>&emsp;&emsp;因此，文章详细的介绍了页面热度转换模块以及页面定位倾向来进行页面在SDD和HDD之间的迁移。<br>（1）页面热度转换模块<br>&emsp;&emsp;文章提出的页面热度转换，同样是多设置了一个warm进行缓冲。假设一个页面一直是cold状态，某次访问是一次热访问（即访问的时间间隔很小），这次访问使系统误判它为hot页面，从而带来一次迁移操作．但是紧接着该页面又回到cold状态，这可能又会带来一次迁移操作，所以不准确的页面分类会使迁移操作大大增加。而warm可以一定程度上减少这种情况。这个模块为每一个页面设置了冷热状态以及每次访问的冷热属性。如果页面连续两次物理访问的时间间隔大于阈值，那么就认为是冷访问，反之就认为是热访问。简单的说，就是页面状态在hot和cold之间转换，但是一个hot（cold）页面只有经过连续的两次cold（hot）访问，才能转换为hot（cold）页面，不然会转移到warm状态。同时，如果是从warm切换到冷热状态，还会触发一个状态转换标志，用于页面定位倾向的计算。<br>（2）页面定位倾向和衰减<br>&emsp;&emsp;首先，需要分别计算出HDD和SSD的I/O代价。对于一个数据页面，它的物理访问和逻辑访问都需要被列入统计，并且一个物理访问操作对I/O 代价的计算比逻辑访问操作有更大的影响。并且每个页面的概率都以公式1-l/N 来计算，l表示单个页面的逻辑访问操作计数，Ｎ 表示页面所有访问操作的计数．所以不同的页面拥有不同的概率值，这也反映了不同页面各自的访问负载．文章就是利用这个概率值来衡量逻辑访问操作对I/O代价计算的影响。同时该模型中的计算是基于页面分配以来的I/O统计的，所以它具有明显的累积效应。这意味着以前长时间的访问负载和当前的访问负载对当前的页面定位有着相同的影响。由于累积效应，页面以前的访问负载积累的I/O统计值将会很大，从而使该模型对当前的访问 负载变化不够敏感，这将会导致不准确的页面定位。因此，文章提出了时间衰减因子，时间衰减因子也是动态的。当页面热度状态从warm变为 hot或者cold时，这暗示着页面的当前访问负载可能发生变化，读写倾向性发生改变，所以该页面先前的定位倾向和访问统计对当前的计算不应该有太大的影响． 定位倾向参数trend按因子β减小，并且 访问统计重置。HDD的容量大小设为hddsize，假定每个页面在hddsize次的访问中至少会被访问一次，那么如果页面的两次相邻访问的间隔超过hddsize， 该页面被认为toocold，并且它的定位倾向发生衰减。在这种情况下，衰减因子β 的影响会增大，它的值会被减小ssdsize/interval倍（interval为两次访问的时间间隔），这就使之前的负载对定位倾向的影响减小至几乎０。<br>&emsp;&emsp;对于整体模型，页面必须在热度状态为 warm 或者hot，并且定位倾向为SSD-trend时，该页面才能被迁移到SSD 上存储．而从SSD 到HDD 的迁移触发条件则不相同。一旦SSD页面的定位倾向为HDD-trend，则该页面被迁移到HDD，此外对某些写操作性能不输于读操作的高端SSD而言，热度状态的变化也是迁移操作的触发条件，当页面变为cold时迁移发生也就是说，本文的系统是兼容高端SSD和中端SSD的。<br><br><br><strong>读后思考及想法：</strong><br>&emsp;&emsp;总体看下来，文章是在一个已经存在的混合存储模型上加以改进，提出了比较重要的两点更新，冷热状态中warm的加入和定位倾向中衰减因子的加入。虽然文章给出的算法很巧妙，尤其是定位倾向的算法，但是对于其中的具体实现，还是有些地方存在疑惑。从文章给出的思路以及伪代码来看，一个页面的hddcost和ssdcost除开逻辑操作概率值，几乎是确定的值，因为物理读，物理写代价都是提前设定好的。所以整个算法其实是兼顾考虑了读写和hdd以及ssd之间的差异，但是读写代价是怎么来的，怎样设置比较合理，文章没有给出解释，是否需要大量的实验进行比较来得出。<br>&emsp;&emsp;同时文章其实只考虑了性能，尽管文章有提到性价比的比较，但是只是在实验中进行不同SSD和HDD的容量比的性能对比来体现。但实际上我认为，还需要考虑SSD和HDD的磨损情况，理想情况下，二者的寿命应该是相同的，但是文章并没有考虑这一点。因此，我认为还可以增加一个磨损因子在算法的定向参数计算中，考虑SSD和HDD的理论读写次数和已经读写次数的比值，进而影响定向的比较。至于SSD和HDD的磨损平均，可以交给各自的管理器去实现，不需要在迁移算法中有所体现。</p>
<hr>
<h2 id="四、A-Hybrid-Solid-State-Storage-Architecture-for-the-Performance-Energy-Consumption-and-Lifetime-Improvement"><a href="#四、A-Hybrid-Solid-State-Storage-Architecture-for-the-Performance-Energy-Consumption-and-Lifetime-Improvement" class="headerlink" title="四、A Hybrid Solid-State Storage Architecture for the Performance, Energy Consumption, and Lifetime Improvement"></a>四、A Hybrid Solid-State Storage Architecture for the Performance, Energy Consumption, and Lifetime Improvement</h2><p><strong>内容解读：</strong><br>&emsp;&emsp;文章主要介绍的是一种基于日志的闪存异地更新，不过与普通的情况不同的是，文章考虑到由于NAND闪存的写前擦除特性，以及擦除块大小的原因，并不适合日志的形式，因为会造成同一数据的冗余更新，以及额外擦除等情况。因此，使用了PRAM作为闪存的日志区，以此构成一个混合式存储体系。 PRAM相比较NAND闪存最大的优势就是可以实现本地更新，并且访问粒度远小于NAND闪存，这样就可以解决上述问题。<br>&emsp;&emsp;同时与普通的基于日志的闪存异地更新不同的是PRAM 日志区域与工作中基于闪存的数据区域分离，即在物理地址上是分离的，但是在逻辑上是一起的。以日志区域动态分配模式为例，对于写操作，有三种情况。<br>（1）数据页没有日志记录，动态分配一个，并且写入更新。<br>（2）已经有日志记录，将之前的日志记录和当前进行比较，如果是相同数据地址的进行覆盖。<br>（3）如果不匹配，则将更新写入，如果没有空余日志记录区，则动态分配一个。<br>&emsp;&emsp;对于读操作，对于读操作，如果存在日志区，也就是说之前存在过更新，因此需要先进行合并。<br>&emsp;&emsp;对于日志区域的分配，文中提出了三种不同的方法。首先是简单的静态分配，就是所有的擦除单元平均分配日志区域，但是考虑到数据访问的不平衡性，会导致某些经常访问的擦除单元因为日志区域大小不够而经常发生合并操作，而一些更新不频繁的擦除单元则长时间闲置，最终导致资源的分配不均以及磨损的不平衡。为了解决这种问题，文章又提出了一种称之为静态组的分配方式，也就是多个擦除单元合并为一个组进行管理，并且这些擦除单元的数据区共享这个组中的日志区，这样就可以为族中那些经常发生更新的擦除单元分配更多的日志区，以此来减少擦除的次数。但是由于日志区共享，这样就导致了每次合并操作族中的擦除单元需要全部参与。这样就导致了新的问题，可能一个组中只有几个擦除单元经常更新，并导致许多合并操作。但是由于整个组在合并操作中被擦除并写入一起，因此即使没有任何修改，大多数页面也将被擦除。为了克服静态赋值的一些局限性，提出了一种动态分配，即日志页在所有擦除单位中共享，但是，一个擦除单元的合并操作不会影响其他擦除单元。动态分配也有需要考虑的地方，那就是何时进行合并操作，动态分配无法在没有新日志区时进行合并，这是因为当一个擦除单元日志区不够用时，会从自由日志区中调出新的进行分配，所以只有当所有的日志区被用完时，才是擦除单元没有足够日志区的时候，但是此时进行合并操作会导致系统必须中断服务，直到合并完成，这是因为再没有新的日志区来解决突发的写操作。但是这样的宕机时间是不能够接受的，因此通过设置阈值来解决这个问题，当剩余的空余日志区域低于阈值时就进行合并操作，以此来保证依旧存在空间来满足突发访问。同时，文章甚至还考虑了对于合并的选择，合并应该也是可以进行选择的，对于那些经常访问的热页面，应该尽量避免去合并这些页面，因为PRAM是允许就地更新的，因此让PRAM日志去进行就地更新远比多次合并更加合适。同时还需要考虑日志页的磨损情况，因为PRAM能够就地更新的特性，热数据会不断在日志区中被覆盖更新，这就导致了冷热数据的磨损情况不平衡。于是在进行日志页面分配的时候，使用链式结构，链式结构根据日志页面的擦除次数进行排序，这样就能够保证在一定程度上解决冷热数据导致的日志页面磨损不均的情况。<br>&emsp;&emsp;最后的实验结果表明，如果日志区域允许在没有多级存储支持的情况下进行就地更新，闪存的性能可以显著提高。同时上述方法可以减少读取操作的开销，并增加存储系统的使用寿命。此外，可降低读写操作的能耗。更重要的是，PRAM 的就地更新功能提供了更灵活的管理策略，可进一步优化性能和生存期。  <br><br><br><strong>读后思考及想法：</strong><br>&emsp;&emsp;文章提出的方法是对于NAND闪存性能的改进。主要的着眼点在于使用可以就地更新的PRAM作为闪存的日志区域来最大限度的解决NAND闪存写前擦除的问题。同时对于日志区域的管理，文章也给出了自己的方式，同时考虑了磨损等问题。最核心的点，我认为在于提出的动态分配的模式，这种方式能够比较有效的解决静态分配带来的一些问题以及性能的限制。但是有一点我还是比较在意，那就是最后的合并时机，文章给出的方案尽管保证了每个擦除单元的独立，一个擦除单元的合并操作不会影响其他擦除单元。但是合并的时机是一样的，都是在空余的日志区域低于阈值时进行合并。事实上，这样的策略是基于平均日志区域的磨损，但是考虑数据区的话，是否会出现这样的情况：某几个擦除单元频繁进行更新，但是剩下的擦除单元仅仅只是少数更新，在这样的情况下当空余的日志区域低于阈值时，就会引发所有擦除单元的合并，但是那些仅仅只是少数更新的擦除块进行更新事实上是没有必要的，或者说对于擦除的损耗来说是不值得的。是否可以再加一个阈值，在进行合并的时候，只有当擦除单元的日志区域大于该阈值时才能进行合并。但同时，为了避免擦除单元长时间不进行更新，导致日志区无法参与磨损平均，我觉得是不是可以添加一个计时器，设置一个阈值，如果长时间得不到更新，就把当前的擦除单元合并，以便于日志区域的磨损平均。有点类似于冷热数据，热数据要尽力避免合并，但是冷数据就应该及时合并。这样不仅可以腾出更多的日志区用于热数据，也有利于日志单元的磨损平均。<br>&emsp;&emsp;还有一点有些疑惑，文中提到提到热数据，检测到热数据时，可以在合并时机到来时不进行合并，但是在检测热数据时，文中只是简单的提到可以使用简单的FIFO来记录最近使用的数据，我查阅资料，但是不是很清楚具体的使用方式，因为队列的长度很影响热数据的检测，如果过长，即使是热数据可能也会判定为冷数据，如果过短，可能又会把冷数据判断为热数据。或者说和之前的论文中提到的一样，设置一个warm区间，根据在warm区间的时间再去判断是否是冷热数据。<br>&emsp;&emsp;再有就是，目前文章提到的基于日志的异地更新，虽然我知道其基本原理和作用，但是查阅资料之后，还是对于其具体实现很感兴趣并且有些疑惑。比如日志怎么存，是键值对吗？合并的具体操作又是如何。这些还需要后续的阅读和调查。</p>
<hr>
<h2 id="五、Design-Guidelines-of-Storage-Class-Memory-Flash-Hybrid-Solid-State-Drive-Considering-System-Architecture-Algorithm-and-Workload-Characteristic"><a href="#五、Design-Guidelines-of-Storage-Class-Memory-Flash-Hybrid-Solid-State-Drive-Considering-System-Architecture-Algorithm-and-Workload-Characteristic" class="headerlink" title="五、Design Guidelines of Storage Class Memory/Flash Hybrid Solid-State Drive Considering System Architecture, Algorithm and Workload Characteristic"></a>五、Design Guidelines of Storage Class Memory/Flash Hybrid Solid-State Drive Considering System Architecture, Algorithm and Workload Characteristic</h2><p><strong>内容解读：</strong><br>&emsp;&emsp;本文作为一篇设计指南性质的文章，主要介绍了两个体系结构 ：<br>&emsp;&emsp;1、使用 SCM 作为基于写回非易失性内存 （NVM） 的缓存，<br>&emsp;&emsp;2、使用 SCM 作为存储设备。<br>&emsp;&emsp;同时由于 SCM 芯片延迟因存储器器件和电路设计而异，在五种 SCM 芯片设计方案下评估了三种 SSD 数据管理算法，以提供 SCM/NAND 闪存混合 SSD 的有用设计指南。<br>&emsp;&emsp;接下来分别介绍三种数据管理算法以及五种芯片。<br>&emsp;&emsp;这三种数据管理算法需要提前将数据进行归类之后才能够进行工作，在文中提出了一种数据归类模式。数据按照读/写-冷/热-随机/顺序（与 NAND 闪存的物理页面大小相比，请求根据其大小判断为随机/顺序。当数据大小大于 NAND 闪存页大小的一半时，控制器将访问判断为顺序）分成八类，值得注意的是，在现实生活中找不到读取热顺序的工作负载，因此，不对此类进行考虑。<br>&emsp;&emsp;三种管理算法分别是回写 （WB） NVM 缓存算法、写入优化数据管理 （WO-DM） 算法和读写平衡数据管理 （RWB-DM） 算法。<br>（1）回写 （WB） NVM 缓存算法<br>&emsp;&emsp;对于写回算法，就好比是操作系统中cache的写回算法。数据最初存储到 SCM。将数据写入 SCM 后，将向主机发送确认，指示写入请求完成。因此，写入的响应时间取决于 SCM 的写入速度。当 SCM 几乎已满时，冷数据将使用LRU替换算法逐出到 NAND 闪存。在读取过程中，直接从相应的内存设备检索数据。如果数据在 SCM 中，主机从 SCM 读取。否则，主机从 NAND 闪存读取数据，数据将复制到 SCM。这样就能尽量将热数据保存在SCM中，冷数据保存在NAND闪存中。同时由于SVM的非易失性，提高了效率和安全。<br>（2）写入优化数据管理 （WO-DM） 算法<br>&emsp;&emsp;该算法是在写回算法的基础之上对写入做了改进。在写回算法中，所有的写入请求都会写入到SVM中，这样会导致总有冷数据占据了一定空间的SVM，导致SVM缓存的命中率下降。因此，在写入过程中加以改进，写入热或写入随机数据存储到 SCM，而写入冷或序列数据直接存储到 NAND 闪存。当 SCM 空间几乎已满时，使用冷数据逐出算法将冷数据逐出从 SCM 到 NAND 闪存的冷数据（零碎数据），最大限度保证缓存的命中率。<br>（3）读写平衡数据管理 （RWB-DM） 算法<br>&emsp;&emsp;在写入优化之后，追求更好的读取，最好的情况就是每次都从缓存中读取。因此，在读取操作期间，读取热数据或读取随机数据从 NAND 闪存移动到 SCM，如图 3 [4] 所示。请注意，数据在迁移过程中移动而不是复制，这不同于 WB NVM 缓存。SSD 中没有数据副本。因此，写入热、写入随机、读取热或读随机数据存储在 SCM 中。只有写入-冷顺序或读冷顺序数据存储在 NAND 闪存中。类似于把缓存当作另一个存储器。<br>五种芯片则是根据读写延迟的不同进行划分，因为读写延迟是决定芯片性能的两个最关键因素。五种芯片的读写延迟依次增加。<br>&emsp;&emsp;根据不同芯片，不同算法，不同数据类型，文章做了大量的实验。实验主要研究的是在SCM与NAND闪存的容量比不同的情况下，面对不同数据类型、不同SVM芯片，不同数据管理算法在SSD性能（IOPS），能耗，寿命的表现。<br>&emsp;&emsp;从SSD性能的实验结果来看，没有一个适合所有情况的算法，当SCM 快速并且读取冷随机工作负载时，WB NVM 缓存算法实现了最佳 IOPS。但是，如果 SCM 较小且速度慢，则 WO-DM 的性能优于 WB NVM 缓存算法。从能耗来看，尽管带 WO-DM 的 SSD 对 NAND 闪存的写入数据流量最小，但其读取能耗很高。这表明，随着 NAND 闪存主导混合 SSD 的能耗，从 NAND 闪存读取更多数据。因此，SSD 读取性能受到影响。这解释了为什么WO-DM无法达到最高的 IOPS，即使它到 NAND 闪存的流量是最小的。使用 RWB-DM 的 SSD 的写入能耗很高，表明 NAND 闪存的写入数据流量更多。它还会导致更高的写入放大，从而降低 SSD 的耐用性和性能。从寿命来看，增加 SCM 容量过度调配可减少 SCM 和 NAND 闪存的 W/E 周期。此外，随着 SCM/NAND 闪存容量比的增加，SCM 和 NAND 闪存的 W/E 比被抑制，这表明增加 SCM 过度配置容量有助于减少 NAND 闪存芯片之前 SCM 芯片磨损的情况。因此，可以延长混合 SSD 寿命。但是，还需要考虑由于额外的 SCM 过度调配而增加的成本。  <br><br><br><strong>读后思考及想法：</strong><br>&emsp;&emsp;文章其实没有提出比较新颖的观点，但是对于不同的工作负载特征做了对比试验，三种不同的数据管理算法，虽然是一步步递进的优化，但是在我看来其实已经属于不同的架构。回写 （WB） NVM 缓存算法和写入优化数据管理 （WO-DM） 算法本质是服务于SCM作为NAND闪存的闪存。但是读写平衡数据管理 （RWB-DM） 算法有点像是把SCM单独考虑成了一种存储器。所以这三者之间的比较，其实也是一定程度上，两种架构的比较。当然，和实验结果一样，面对不同的工作负载情况，没有一种算法是完全适合的。WO-DM 是所有密集工作负载的最佳选择，因为 WO-DM 针对高度密集写入工作负载进行了优化。对于读取热随机工作负载，RWB-DM 工作得很好。对于读取冷随机工作负载，WB NVM 缓存算法通过快速 SCM 芯片实现最佳性能，而 WO-DM 在慢速 SCM 芯片方案中运行良好。此外，在八类工作负载（读冷顺序）的算法之间，没有观察到较大的性能差异。不考虑SCM芯片的快慢方案，基本可以看到RWB-DM在读取热随机数据时效果更好，这是因为它把SCM芯片当作了单独的存储设备来存储热随机数据。而在其他方面，似乎都是WO-DM更占优势。那是否可以将SCM分成两部分，一部分作为缓存进行冷数据的进一步筛查，另一部分则直接存放热数据，虽然管理会变得更加复杂，但是这样可以综合二者的优势。</p>
<hr>
<h2 id="六、Design-of-Hybrid-SSDs-With-Storage-Class-Memory-and-nand-Flash-Memory"><a href="#六、Design-of-Hybrid-SSDs-With-Storage-Class-Memory-and-nand-Flash-Memory" class="headerlink" title="六、Design of Hybrid SSDs With Storage Class Memory and nand Flash Memory"></a>六、Design of Hybrid SSDs With Storage Class Memory and nand Flash Memory</h2><p><strong>内容解读：</strong><br>&emsp;&emsp;在内存金字塔中，SLC NAND、MLC NAND、TLC NANA、QLC NAND性能依次下降，但是容量和价格却依次提升。文章提出了三种混合SSD架构，包括（1）MLC/TLC nand闪存混合SSD;（2） SCM/MLC nand 闪存混合 SSD;和 （3） SCM/MLC/TLC nand 闪存三混合 SSD。通过建议的混合 SSD，SCM 提高了 SSD 性能，而 TLC nand 闪存可延长 MLC nand 闪存耐用性并降低 SSD 成本。<br>（1）MLC/TLC nand闪存混合SSD<br>&emsp;&emsp;TLC nand 闪存的写入单元是多个页面块，以减少单元对单元耦合效果。而 SLC 和 MLC nand 闪存的写入单元是一页。在 TLC nand 闪存中覆盖页面时，必须读取块中的所有有效页面并写入另一个 TLC nand 闪存块。这会导致 TLC nand 闪存的性能下降。通常，SRAM 可用作写入缓冲区，并在它们等待写入 TLC nand 闪存时存储数据。但是，SRAM 具有高成本和小容量。为了平衡TLC nand闪存的低成本和大容量写入缓冲器，MLC/TLC闪存混合SSD才被提出。因为性能差异，需要仔细选择写入 TLC nand 闪存的数据。为了减少数据流量到TLC nand闪存，TLC nand 闪存仅存储静态冻结数据。而如何进行这些冷数据的收集，文章提出了一种循环冻结数据收集办法（RR-FDCA）。在这个算法中，以循环的方式选择受害者快（victim block）,每次都找最早无效的块，这样可以一定程度上保证磨损平均。而受害者块中有效的数据则被认为是冻结数据，放入到TLC NAND中，以减少TLC NAND的覆盖，以此提升性能。<br>（2）SCM/MLC nand 闪存混合 SSD<br>&emsp;&emsp;与之前的模式相同，同样是将冷热数据进行分开存放，但是在这个模式下，文章提出了三种数据管理算法。<br>&emsp;&emsp;Write-Back Nonvolatile Memory Cache (WB NVMCache)<br>&emsp;&emsp;Cold Data Eviction (CDE)<br>&emsp;&emsp;Read-Write-Balanced Data Management (RWB-DM)<br>&emsp;&emsp;这三种算法和之前论文中提到的基本一样，这里不再赘述。<br>（3）SCM/MLC/TLC nand 闪存三混合 SSD<br>&emsp;&emsp;SCM/MLC/TLC nand 闪存三混合 SSD 通过将 SCM 添加到 MLC/TLC nand 闪存混合 SSD 而设计，这进一步提高了 MLC/TLC nand 闪存混合 SSD 的性能。使用TLC nand闪存的主要原因是其低成本。TLC nand 闪存具有更长的读写延迟，但其成本约为 MLC nand 闪存成本的三分之二。与 SCM/MLC nand 闪存混合 SSD 相比，SCM 的成本增加可以通过使用低成本 TLC nand 闪存来补偿。因此，以更低的成本实现相同的 IO/秒。在这里，SCM 仍用作存储设备。在数据管理中采用了CDE和RR-FDCA的组合）。首先，来自主机的热或随机数据存储在 SCM 中，冷顺序数据存储在 MLC nand 闪存中，如 CDE 中设计。其次，RR-FDCA 管理 MLC 和 TLC nand 闪存之间的数据。在 MLC nand 闪存的 GC 操作期间，MLC nand 闪存（称为冻结数据）中的有效页面被复制到 TLC nand 闪存。因此，SCM 存储热数据，MLC nand 闪存存储冷数据，TLC nand 闪存存储冻结数据。  <br><br><br><strong>读后思考及想法：</strong><br>&emsp;&emsp;尽管三种数据管理算法和之前论文中提到的几乎相同，但是文章中的很多点，我还是第一次看到。<br>&emsp;&emsp;比较有意思的是文中提到的RR-FDCA，用来筛选出所谓的冻结数据。乍一听，算法很简单，好像不应该这样理所当然，但是仔细想一下，每次都去寻找保留时间最久的块作为受害者块，说明，这个块中的数据起码已经经过了整个容量大小的访问时间。但是其中依旧还存在着有效数据，说明这些有效数据在整个容量大小的访问时间过程中都没有再被访问，确实可以被认为是冻结的数据。有点类似于LRU队列，但是不需要额外的结构。不过在面对数据量比较大的任务的情况下，感觉效果可能会差些。<br>&emsp;&emsp;还有就是三混合。之前的论文中没有提到过三混合，从实现角度来看，三混合更像是多级缓存，不同性能的不同存储介质存储不同类型的数据，把数据的划分变得更加细致，虽然更加有利于发挥每种介质的特性，但是带来的管理难度和数据流向延迟也需要均衡考虑。然后我就想到之前论文中提到的使用PRAM作为NAND闪存日志区的混合模型，是否可以再额外做一个混合，加一个缓冲区，进一步减少写前擦除带来的影响。不过成本也会提高，还是需要看应用的实际情况。</p>
<hr>
<h2 id="七、一种面向SSD-HDD混合存储的热区跟踪替换算法"><a href="#七、一种面向SSD-HDD混合存储的热区跟踪替换算法" class="headerlink" title="七、一种面向SSD-HDD混合存储的热区跟踪替换算法"></a>七、一种面向SSD-HDD混合存储的热区跟踪替换算法</h2><p><strong>内容解读：</strong><br>&emsp;&emsp;文章主要内容是提出了一种面向云计算这样的多任务共享存储系统的环境，设计适合 SSD-HDD 混合存储系统使用的替换算法，尽力避免发生 SSD 数据块替换时， 热点区域数据块被替换掉的情况。这个算法的前提需要把数据进行分类，存储空间被分成大小一致的若 干个连续的区(Zone)。当区的大小为256MB时，分别统计各个区在一段时间内的访问次数，将一个时期内区内数据块访问次数相对多的区称为这个时期的“热区( Hot Zone) ”，访问少的区叫做“冷区( Cold Zone) ”。集中访问模式的大部分 I/O 工作流都集中在一定数量的热区内，显然热区的数据块被再次访问的概率高于冷区，而冷区的访问大部分是由随机 I/O 工作流 产生的请求。<br>&emsp;&emsp;那这个替换算法的目标就是尽可能的把热区数据保留在缓存之中。有些类似于冷热数据的区分，但是冷热数据一般使用先进先出队列，但是对于一段时间内的访问次数，先进先出可能不能有效识别。如果用计数器再进行遍历，又会使效率低下。所以文章提出了一种类似于 Linux 内核的页高速缓存机制的基树( Radix Tree) 的数据结构来管理区访问历史。<br>&emsp;&emsp;基树的叶子节点指向每个区，每个叶子节点记录区的热度值(访问计数) 、区数据块计数、节点访问计数。非叶子节点记录其所有子节点的汇总信息，每个节点包含的子节点的个数称为基，基树的高度由基树的基和区的个数决定。基数的叶子节点包含一个指向该区数据块 LRU 链表的指针。<br>&emsp;&emsp;这样，所有节点中需要包含一个热度值。每次对区内数据块的访问，该区的热度之都要加1，并且所有父节点都需要加1。又因为这样的话，很可能导致一些高层非叶节点的热度值溢出，所以需要在节点的热度值溢出的时候，把本节点的所有热度值右移1位，热值右移1位相当于使这一个时刻之前的热度值的权重降为1 /2，使近期的访问量在热度值中占有更高的权重。当一个区内的数据块长时间没有访问时，其热度值将不断变小直至变为0，成为冷区。<br>&emsp;&emsp;有了这样的管理结构，替换方法就会变得很简单。被替换数据块的选取原则是从 SSD 中 热度值最低的冷区中选取，当被选中的冷区包含多个数据块时，则依据LRU算法选取，冷区的查找是从根节点开始的，首先找到本层热度值最低且在SSD中有数据块的区节点，然后依次向下一层查找，最后检索到的叶子节点所指向的区就是要查找的冷区。<br>&emsp;&emsp;同时，根据多任务的 I/O 工作流具有顺序访问和区域集中的特性，可以采取预取策略增加命中率，可以采用两种预取策略: 一是定期扫描热区的信息，选择热度值高的区，调入这些区的未调入的数据块。二是在数据块调入时，查看该区的热度值是否达到一定门限，如果是，则试图调入该数据块之后的几个数据块。<br>&emsp;&emsp;在实验中，典型多任务共享存储环境下HZT算法可以使SSD缓存的命中率比使用 LRU( Least Recently Used) 算法的系统提高12%。采用适当的预取策略，该算法的命中率与 LRU 算法相比可获得 23% 的提升。  <br><br><br><strong>读后思考及想法：</strong><br>&emsp;&emsp;文章在提升SSD-HDD混合存储性能的着眼点是缓存的替换算法。和之前论文中提到的冷热数据监测和替换算法不同，文章提出的算法是先将数据分成较大的块，替换时再去块中进行查找替换，而不是直接以数据块的单位进行。或许这个是借鉴了操作系统中的重要概念，局部性原理。<br>&emsp;&emsp;其次就是提出的独特的数据管理结构。简单的去了解了一下Radix Tree，发现这是用来解决hash冲突和hash表过大的替代品。适合处理非常长的、可变长度的键值。用来作为热区识别，确实有异曲同工之妙。但是文中对于热度值溢出的处理，我还有一点不明白的地方，文中提到随着访问量增加，热度值可能溢出( 尤其是上层节点) ，节点内所有热度值右移1 位不会改变本节点内的热度排序，所以不需要修改同层不同节点和不同层节点。不需要修改不同层节点我能够理解，但是不需要修改同层不同节点，那在最后替换时不是就影响选择了吗。这一点暂时还是不能理解。</p>
<hr>
<h2 id="八、Cost-Capacity-and-Performance-Analyses-for-Hybrid-SCM-NAND-Flash-SSD"><a href="#八、Cost-Capacity-and-Performance-Analyses-for-Hybrid-SCM-NAND-Flash-SSD" class="headerlink" title="八、Cost, Capacity, and Performance Analyses for Hybrid SCM/NAND Flash SSD"></a>八、Cost, Capacity, and Performance Analyses for Hybrid SCM/NAND Flash SSD</h2><p><strong>内容解读：</strong><br>&emsp;&emsp;文章主要的着眼点在于经济性。<br>&emsp;&emsp;由于工作负载特性的多样性，因此需要对 SCM 和 NAND 闪存容量要求进行分析，以满足每个应用程序的性能约束。除此之外，SCM芯片的设计需要在芯片区域和芯片的各种延迟之间进行平衡。当使用具有不同的延迟参数的 SCM 芯片时，预期需要不同的最佳 SCM 容量要求。因为SCM芯片成本与芯片区域直接相关，而芯片区域又依赖于设计中的写入和读取延迟参数。因此，根据SCM芯片的SCM容量要求和面积成本模型，就可以进行经济高效的SCM芯片设计。<br>&emsp;&emsp;文章首先比较常规的分析了在典型工作负载的情况下，为了达到应用要求，SCM的容量与SCM的读写延迟之间的关系。实验得到了许多结论，像是当SCM的写入或读取延迟时间较长时，SSD吞吐量将受到抑制等。<br>&emsp;&emsp;进一步，文章探讨了SCM延迟参数对SCM芯片面积的依赖性。由于芯片成本与芯片面积直接相关，因此可以得出SCM成本对芯片延迟的依赖性。但是当PRAM的写入和读取延迟改变时，存储器阵列，字线解码器，读出放大器等的大小将相应地改变，所以说为每个不同的值选择面积变化的程度并不是精确的科学，而是取决于要素之间的复杂交互作用，例如布局物理设计规则，布局块纵横比，晶体管驱动电流，寄生电容，噪声余量 ，电源平面等。因此文章给出了一个数学模型来进行近似模拟。<br>&emsp;&emsp;总而言之，所需的最小SCM容量和读取延时应由工作负载类型和SCMwrite / read延迟比率确定。 给定足够的应用程序SCM容量，则存在最佳SCM延迟参数，可将SCM成本降至最低。    <br><br><br><strong>读后思考及想法：</strong><br>&emsp;&emsp;在之前的论文中基本都是不考虑延迟参数带来的成本，只考虑SCM和NAND的容量之比，而这篇文章则给出了新的观点，那就是还需要考虑延迟和芯片面积的平衡，进而找到最佳的性价比。也是从一个新的角度去改进混合式存储。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/data-center-failures/" rel="tag"># data center failures</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/07/27/大规模SSD失效原因分析总结/" rel="next" title="大规模SSD失效原因分析总结">
                <i class="fa fa-chevron-left"></i> 大规模SSD失效原因分析总结
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC8zODQ2NS8xNDk5Mw=="></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="lyjgod">
            
              <p class="site-author-name" itemprop="name">lyjgod</p>
              <p class="site-description motion-element" itemprop="description">哦斯！</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/godlyj" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://nanfengx.top/" title="nanfengx" target="_blank">nanfengx</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#混合式存储相关论文阅读总结"><span class="nav-number">1.</span> <span class="nav-text">混合式存储相关论文阅读总结</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#论文目录"><span class="nav-number">1.1.</span> <span class="nav-text">论文目录</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#一、混合存储综述"><span class="nav-number">1.2.</span> <span class="nav-text">一、混合存储综述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二、基于磁盘和固态硬盘的混合存储系统研究综述"><span class="nav-number">1.3.</span> <span class="nav-text">二、基于磁盘和固态硬盘的混合存储系统研究综述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三、基于磁盘和固态硬盘的混合存储系统研究综述"><span class="nav-number">1.4.</span> <span class="nav-text">三、基于磁盘和固态硬盘的混合存储系统研究综述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四、A-Hybrid-Solid-State-Storage-Architecture-for-the-Performance-Energy-Consumption-and-Lifetime-Improvement"><span class="nav-number">1.5.</span> <span class="nav-text">四、A Hybrid Solid-State Storage Architecture for the Performance, Energy Consumption, and Lifetime Improvement</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#五、Design-Guidelines-of-Storage-Class-Memory-Flash-Hybrid-Solid-State-Drive-Considering-System-Architecture-Algorithm-and-Workload-Characteristic"><span class="nav-number">1.6.</span> <span class="nav-text">五、Design Guidelines of Storage Class Memory/Flash Hybrid Solid-State Drive Considering System Architecture, Algorithm and Workload Characteristic</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#六、Design-of-Hybrid-SSDs-With-Storage-Class-Memory-and-nand-Flash-Memory"><span class="nav-number">1.7.</span> <span class="nav-text">六、Design of Hybrid SSDs With Storage Class Memory and nand Flash Memory</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#七、一种面向SSD-HDD混合存储的热区跟踪替换算法"><span class="nav-number">1.8.</span> <span class="nav-text">七、一种面向SSD-HDD混合存储的热区跟踪替换算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#八、Cost-Capacity-and-Performance-Analyses-for-Hybrid-SCM-NAND-Flash-SSD"><span class="nav-number">1.9.</span> <span class="nav-text">八、Cost, Capacity, and Performance Analyses for Hybrid SCM/NAND Flash SSD</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lyjgod</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
